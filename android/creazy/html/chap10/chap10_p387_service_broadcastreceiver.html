<!doctype html>
<html><!-- InstanceBegin template="/Templates/zjdgx-notes.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="zjdgx" />
<!-- InstanceBeginEditable name="doctitle" -->
<meta name="description" content="第10章 Service与BroadcastReceiver(P387)"/>
<meta name="date" content="20140828" />
<title>zjdgx notes</title>
<!-- InstanceEndEditable -->
<!-- InstanceBeginEditable name="head" -->
<style type="text/css">
	html,body{
		background-color: #fff;
	}
	li{
		list-style: none;
	}
	.main{
		font: 12px/1.8 'microsoft yahei',courier new,times new roman;
	}
	.code {
		margin: 0;
		padding: 5px 10px;
		background-color:#e8e8e8;
		font-family: "Courier New", Courier, monospace;
	}
	p.code {
		margin-left: 2em;
	}
	pre.code {
		margin: 0.5em 0;
		line-height: 150%;
		padding: 0.4em 0.6em;
	}
	ol li {
		list-style: decimal;
	}
	.main h1{
		margin: 0;
		font-size: 14px;
	}
	.main h1 a {
		margin-left: 20px;
	}
	.main .point3 {
		padding-left: 5px;
		margin: 5px 0 5px 4em;
	}
	.main .em,
	.main .underline {
		text-decoration: underline;
	}
	.main .italic {
		font-style: italic;
	}
	.main h2 {
		margin: 0;
		margin-top: 10px;
		margin-left: 2em;
		font-size: 12px;
	}
	.main h3 {
		font-size: 12px;
		font-weight: normal;
		margin: 10px 0 0 3em;
	}
	.main ol {
		margin: 0;
		margin-left: 2em;
	}
	.main ol.h3 {
		margin: 0;
		font-size: 12px;
		margin-left: 4em;
	}
	h4 {
		margin: 0;
		text-indent: 5em;
		font-weight: normal;
	}
	table {
		border-collapse: collapse;
		margin-left: 5em;
	}
	table td,table th {
		padding: 2px 20px;
	}
	.table td,.table th {
		border: solid 1px #ccc;
	}
	.exampleCode {
		margin-left: 5em;
	}
	.example {
		width: 65px;
		color: #f00;
		display: block;
		cursor: pointer;
		padding: 2px 5px;
		font-weight: bold;
		text-align: center;
		background-color: #f8f8f8;
	}
	.example i {
		width: 0;
		margin-left: 5px;
		display: inline-block;
		vertical-align: middle;
		border: 5px solid #f86;
		border-width: 5px 5px 0 5px;
		border-color: #f86 transparent transparent transparent;
	}
	.hidden {
		display: none;
	}
	
</style>
<!-- InstanceEndEditable -->
</head>
<body>
	<div class="main">
		<!-- InstanceBeginEditable name="content" -->
		<h1>第10章 Service与BroadcastReceiver(P387)</h1>
		<h2>本章要点</h2>
		<table cellpadding="0" cellspacing="0">
			<tr>
				<td>Service组件的作用和意义</td>
				<td>创建、配置Service</td>
				<td>启动、停止Service</td>
			</tr>
			<tr>
				<td>绑定本地Service并与之通信</td>
				<td>Service的生命周期</td>
				<td>开发远程AIDL Service</td>
			</tr>
			<tr>
				<td>在客户端程序中调用远程AIDL Service</td>
				<td>TelephonyManager的功能和用法</td>
				<td>监听手机电话</td>
			</tr>
			<tr>
				<td>SmsManager的功能和用法</td>
				<td>监听手机短信</td>
				<td>AudioManager的功能和用法</td>
			</tr>
			<tr>
				<td>Vibrator的功能和用法</td>
				<td>AlarmManager的功能和用法</td>
				<td>BroadcastReceiver组件的作用和意义</td>
			</tr>
			<tr>
				<td>开发、配置BroadcastReceiver组件</td>
				<td>发送广播、发送有序广播</td>
				<td>使用BroadcastReceiver接收系统广播</td>
			</tr>
		</table>
		<h2>10.1 Service简介(P388)</h2>
		<h3>10.1.1 创建、配置Service(P388)</h3>
		<p class="point3">
			Service生命周期:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. abstract IBinder onBind(Intent intent): 必须实现, 应用程序可根据返回的IBinder对象与Service组件进行通信;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. void onCreate(): 当该Service第一次被创建后将立即回调该方法;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;3. void onDestroy(): 当该Service被关闭之前将会回调该方法;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;4. void onStartCommand(Intent intent, int flags, int startId): 每次客户端调用startService(intent)方法启动该Service时都会回调该方法;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;5. boolean onUnbind(Intent intent): 当该Service上绑定的所有客户端都断开连接时将会回调该方法.
			Android运行Service的两种方式:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. 通过Context的startService()方法: 访问者与Service之间没有关联, 即使访问者退出了, Service仍然运行;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. 通过Context的bindService()方法: 访问者与Service绑定在一起, 访问者一旦退出, Service也就终止. 
		</p>
		<h3>10.1.2 启动和停止Service(P390)</h3>
		<h3>10.1.3 绑定本地Service并与之通信(P391)</h3>
		<p class="point3">
			当程序通过startService和stopService()启动、关闭Service时, Service与访问者之间不能通信或数据交换.<br>
			如果需要Service与访问者通信或进行数据交换, 则应该使用bindService()和unbindService启动、关闭Service.<br>
			&nbsp;&nbsp;&nbsp;&nbsp;bindService(Intent service, ServiceConnection conn, int flags): <br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*service: 通过Intent指定要启动的Service;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*conn: 该对象用于监听访问者与Service之间的连接情况.当访问者与Service之间连接成功时将回调该ServiceConnection对象的onServiceConnected(ComponentName name, IBinder service)方法; 当访问者与Service之间断开连接时将回调该ServiceConnection对象的onServiceDisconnected(ComponentName name)方法;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*flags: 指定绑定时是否自动创建Service(0不自动创建, BIND_AUTO_CREATE自动创建).
		</p>
		<h3>10.1.4 Service的生命周期(P395)</h3>
		<p class="point3">
		&nbsp;&nbsp;&nbsp;&nbsp;startService生命周期: onCreate, onStart, onDestroy<br>
		&nbsp;&nbsp;&nbsp;&nbsp;bindService生命周期: onCreate, onBind, onUnbind, onDestroy
		</p>
		<h2>10.2 跨进程调用Service(AIDL)服务(P396)</h2>
		<h3>10.2.1 AIDL服务简介(P396)</h3>
		<p class="point3">
			客户端访问远程Service时, Service会将一个回调对象(IBinder)通过onBind()方法返回客户端. 因此Android的AIDL远程接口的实现类就是IBinder的实现类.
		</p>
		<h3>9.2.2 使用ContentProvider管理多媒体内容(P375)</h3>
		<p class="point3">
			Android为多媒体提供的ContentProvider的Uri:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. MediaStore.Audio.Media.EXTERNAL_CONTENT_URI: 存储在外部存储卡(SD卡)上的音频文件内容的ContentProvider的Uri;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. MediaStore.Audio.Media.INTERNAL_CONTENT_URI: 存储在手机内部存储器上的音频文件内容的ContentProvider的Uri;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;3. MediaStore.Audio.Image.EXTERNAL_CONTENT_URI: 存储在外部存储卡(SD卡)上的图片文件内容的ContentProvider的Uri;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;4. MediaStore.Audio.Image.INTERNAL_CONTENT_URI: 存储在手机内部存储器上的图片文件内容的ContentProvider的Uri;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;5. MediaStore.Audio.Video.EXTERNAL_CONTENT_URI: 存储在外部存储卡(SD卡)上的音频文件内容的ContentProvider的Uri;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;6. MediaStore.Audio.Video.INTERNAL_CONTENT_URI: 储在手机内部存储器上的音频文件内容的ContentProvider的Uri.
		</p>
		<h2>9.3 实现ContentProvider(P378)</h2>
		<h3>9.3.1 创建ContentProvider的步骤</h3>
		<p class="point3">
			ContentProvider开发步骤:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. 实现一个ContentProvider子类, 需要实现增删改查等方法;</br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. 在AndroidManifest.xml文件中注册该ContentProvider.
		</p>
		<p class="point3">
			相关类和方法:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. UriMatcher:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void addURI(String authority, String path, int code);<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int match(Uri uri): 返回标志码(code);<br>
			<strong>ContentProvider可以在一个应用或不同应用中使用.</strong>
		</p>
		<h2>9.4 监听ContentProvider的数据改变(P384)</h2>
		<h3>9.4.1 ContentObserver简介(P384)</h3>
		<p class="point3">
			通知注册在特定Uri上的监听者数据改变的方法:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;getContext().getContentResolver().notifyChange(uri, null);<br>
			为了监听指定ContentProvider的数据变化, 需要通过ContentResolver向指定Uri注册ContentObserver监听器.<br>
			ContentResolver注册监听器的方法:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;registerContentObserver(Uri uri, boolean notifyForDescendents, ContentObserver observer): notifyForDescendents为true, 假如注册监听的uri为content://abc, 那么Uri为content://abc/xyz的数据改变时也会触发该监听器; 如果为false, 就不会触发.
			
		</p>
		<h2>9.5 本章小结(P386)</h2>
		<!-- InstanceEndEditable -->
	</div>
	<script type="text/javascript">
		window.onload = function() {
			var examples = document.getElementsByClassName("exampleCode"),
				len = examples.length;
			for(var i=0; i<len; i++) {
				examples[i].onclick = function() {
					showCode(this);
				}
			}
		};
		function showCode( element ) {
			console.log("click");
			var childNodes = element.childNodes,
				len = childNodes.length,
				codeNode, cls = "";
			for(var i=0; i<len; i++) {
				if(childNodes[i].getAttribute != undefined) {
					cls = childNodes[i].getAttribute("class");
				}
				if(cls != null && cls.length > 0 && cls.indexOf("hidden") > -1) {
					codeNode = childNodes[i];
					break;
				}
			}
			if( codeNode.style.display == "" || codeNode.style.display == "none") {
				codeNode.style.display = "block";
			} else {
				codeNode.style.display = "none";
			}
		}
	</script>
</body>
<!-- InstanceEnd -->
</html>