<!doctype html>
<html><!-- InstanceBegin template="/Templates/zjdgx-notes.dwt" codeOutsideHTMLIsLocked="false" -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="zjdgx" />
<!-- InstanceBeginEditable name="doctitle" -->
<meta name="description" content="第7章 图形与图像处理(P273)"/>
<meta name="date" content="20140507" />
<title>zjdgx notes</title>
<!-- InstanceEndEditable -->
<!-- InstanceBeginEditable name="head" -->
<style type="text/css">
	html,body{
		background-color: #fff;
	}
	li{
		list-style: none;
	}
	.main{
		font: 12px/1.8 'microsoft yahei',courier new,times new roman;
	}
	.code {
		margin: 0;
		padding: 5px 10px;
		background-color:#e8e8e8;
		font-family: "Courier New", Courier, monospace;
	}
	p.code {
		margin-left: 2em;
	}
	pre.code {
		margin: 0.5em 0;
		line-height: 150%;
		padding: 0.4em 0.6em;
	}
	ol li {
		list-style: decimal;
	}
	.main h1{
		margin: 0;
		font-size: 14px;
	}
	.main h1 a {
		margin-left: 20px;
	}
	.main .point {
		padding-left: 5px;
		margin: 5px 0 5px 2em;
		background-color: #f8f8f8;
	}
	.main .point3 {
		padding-left: 5px;
		margin: 5px 0 5px 4em;
	}
	.main .em {
		text-decoration: underline;
	}
	.main h2 {
		margin: 0;
		margin-top: 10px;
		margin-left: 2em;
		font-size: 12px;
	}
	.main h3 {
		font-size: 12px;
		font-weight: normal;
		margin: 10px 0 0 3em;
	}
	.main ol {
		margin: 0;
		margin-left: 2em;
	}
	.main ol.h3 {
		margin: 0;
		font-size: 12px;
		margin-left: 4em;
	}
	h4 {
		margin: 0;
		text-indent: 5em;
		font-weight: normal;
	}
	table {
		border-collapse: collapse;
		margin-left: 5em;
	}
	table td,table th {
		padding: 2px 20px;
	}
	.table td,.table th {
		border: solid 1px #ccc;
	}
	.exampleCode {
		margin-left: 5em;
	}
	.example {
		width: 65px;
		color: #f00;
		display: block;
		cursor: pointer;
		padding: 2px 5px;
		font-weight: bold;
		text-align: center;
		background-color: #f8f8f8;
	}
	.example i {
		width: 0;
		margin-left: 5px;
		display: inline-block;
		vertical-align: middle;
		border: 5px solid #f86;
		border-width: 5px 5px 0 5px;
		border-color: #f86 transparent transparent transparent;
	}
	.hidden {
		display: none;
	}
	
</style>
<!-- InstanceEndEditable -->
</head>
<body>
	<div class="main">
		<!-- InstanceBeginEditable name="content" -->
		<h1>第7章 图形与图像处理(P273)</h1>
		<h2>本章要点</h2>
		<table cellpadding="0" cellspacing="0">
			<tr>
				<td>Android的图形处理基础</td>
				<td>Bitmap与BitmapFactory</td>
				<td>继承View来绘制Android中的图</td>
			</tr>
			<tr>
				<td>掌握Canvas、Paint、Path等绘图API</td>
				<td>双缓冲机制</td>
				<td>使用Matrix对图像进行几何变换</td>
			</tr>
			<tr>
				<td>通过drawBitmapMesh方法扭曲图像</td>
				<td>使用不同的Shader类渲染图形</td>
				<td>逐帧动画</td>
			</tr>
			<tr>
				<td>补间动画</td>
				<td>开发自定义补间动画</td>
				<td>SurfaceView的绘图机制</td>
			</tr>
			<tr>
				<td>继承SurfaceView开发动画</td>
			</tr>			
		</table>
		<h2>7.1 使用简单图片(P274)</h2>
		<h3>7.1.1 使用Drawable对象(P274)</h3>
		<h3>7.1.2 Bitmap和BitmapFactory(P274)</h3>
		<p class="point3">
			1. Bitmap封装成BitmapFactory对象: <br>
			&nbsp;&nbsp;&nbsp;&nbsp;BitmapFactory drawable = new BitmapFactory(bitmap);<br>
			2. 通过BitmapFactory获取Bitmap对象: <br>
			&nbsp;&nbsp;&nbsp;&nbsp;Bitmap bitmap = drawable.getBitmap();
		</p>
		<p class="point3">
			Bitmap创建新的Bitmap对象的方法:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. createBitmap(Bitmap source, int x, int y, int width, int height): 从源位图source的指定坐标(x,y)开始, 从中挖取(width, height)的一块来创建新的Bitmap对象;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. createScaledBitmap(Bitmap src, int dstWidth, int dstHeight, boolean filter): 对源位图src进行缩放成宽dstWidth、高dstHeight的新位图;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;3. createBitmap(int width, int height, Bitmap.Config config): 创建一个宽width、高height的新位图;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;4. createBitmap(Bitmap source, int x, int y, int width, int height, Matrix m, boolean filter): 从源位图source的指定坐标(x,y)开始挖取(width,height)来创建新的Bitmap对象, 并按Matrix指定的规则进行变换.
		</p>
		<p class="point3 em">
			获取/assets/资源: AssetManager asset = getAssets;
		</p>
		<h2>7.2 绘图(P277)</h2>
		<h3>7.2.1 Android绘图基础: Canvas、Paint等(P277)</h3>
		<table class="table" cellpadding="0" cellspacing="0">
			<caption>表7.1 Canvas的绘制方法</caption>
			<tr>
				<th>方法签名</th>
				<th>简要说明</th>
			</tr>
			<tr>
				<td>drawArc(RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)</td>
				<td>绘制弧</td>
			</tr>
			<tr>
				<td>drawBitmap(Bitmap bitmap, Rect src, Rect des, Paint paint)</td>
				<td>在指定点绘制从源位图中挖取的一块</td>
			</tr>
			<tr>
				<td>drawBitmap(Bitmap bitmap, float left, float top, Paint paint)</td>
				<td>在指定点绘制位图</td>
			</tr>
			<tr>
				<td>drawCircle(float cx, float cy, float radius, Paint paint)</td>
				<td>在指定点绘制一个圆形</td>
			</tr>
			<tr>
				<td>drawLine(float startX, float startY, float stopX, float stopY, Paint paint)</td>
				<td>绘制一条线</td>
			</tr>
			<tr>
				<td>drawLines(float[] pts, int offset, int count, Paint paint)</td>
				<td>绘制多条线</td>
			</tr>
			<tr>
				<td>drawOval(RectF oval, Paint paint)</td>
				<td>绘制椭圆</td>
			</tr>
			<tr>
				<td>drawPath(Path path, Paint paint)</td>
				<td>沿着指定path绘制任意形状</td>
			</tr>
			<tr>
				<td>drawPoint(float x, float y, Paint paint)</td>
				<td>绘制一个点</td>
			</tr>
			<tr>
				<td>drawPoints(float[] pts, int offset, int count, Paint paint)</td>
				<td>绘制多个点</td>
			</tr>
			<tr>
				<td>drawRect(float left, float top, float right, float bottom, Paint paint)</td>
				<td>绘制矩形</td>
			</tr>
			<tr>
				<td>drawRoundRect(RectF rect, float rx, float ry, Paint paint)</td>
				<td>绘制圆角矩形</td>
			</tr>
			<tr>
				<td>drawText(String text, int start, int end, Paint paint)</td>
				<td>绘制字符串</td>
			</tr>
			<tr>
				<td>drawTextOnPath(String text, Path path, float hOffset, float vOffset, Paint paint)</td>
				<td>沿着路径绘制字符串</td>
			</tr>
			<tr>
				<td>clipRect(float left, float top, float right, float bottom)</td>
				<td>剪切一个矩形区域</td>
			</tr>
			<tr>
				<td>clipRegion(Region region)</td>
				<td>剪切指定区域</td>
			</tr>
		</table>
		<p class="point3">
			Canvas提供的变换方法:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. rotate(float degress, float px, float py): 对Canvas执行旋转;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. scale(float sx, float sy, float px, float py): 对Canvas执行缩放;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;3. translate(float dx, float dy): 移动Canvas.
		</p>
		<table class="table" cellpadding="0" cellspacing="0">
			<caption>表7.2 Paint的常用方法</caption>
			<tr>
				<th>方法签名</th>
				<th>简要说明</th>
			</tr>
			<tr>
				<td>setARGB(int a, int r, int g, int b)/setColor(int color)</td>
				<td>设置颜色</td>
			</tr>
			<tr>
				<td>setAlpha(int a)</td>
				<td>设置透明度</td>
			</tr>
			<tr>
				<td>setAntiAlias(boolean aa)</td>
				<td>设置是否抗锯齿</td>
			</tr>
			<tr>
				<td>setPathEffect(PathEffect effect)</td>
				<td>设置绘制路径时的路径效果</td>
			</tr>
			<tr>
				<td>setShader(Shader shader)</td>
				<td>设置画笔的填充效果</td>
			</tr>
			<tr>
				<td>setShadowLayer(float radius, float dx, float dy, int color)</td>
				<td>设置阴影</td>
			</tr>
			<tr>
				<td>setStrokeWidth(float width)</td>
				<td>设置画笔的笔触宽度</td>
			</tr>
			<tr>
				<td>setStrokeJoin(Paint.Join join)</td>
				<td>设置画笔转弯处的连接风格</td>
			</tr>
			<tr>
				<td>setStyle(Paint.Style style)</td>
				<td>设置Paint的填充风格</td>
			</tr>
			<tr>
				<td>setTextAlign(Paint.Align align)</td>
				<td>设置绘制文本时文字的对齐方式</td>
			</tr>
			<tr>
				<td>setTextSize(float textSize)</td>
				<td>设置绘制文本时的文字大小</td>
			</tr>
		</table>
		<h3>7.2.2 Path类(P281)</h3>
		<p class="point3">
			路径(Path)绘制效果类(PathEffect)的每一个子类代表一种绘制效果, 其子类有:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;ComposePathEffect、CornerPathEffect、DashPathEffect、DiscretePathEffect、PathDashPathEffect、SumPathEffect.
		</p>
		<h3>7.2.3 绘制游戏动画(P284)</h3>
		<h2>7.3 图形特效处理(P292)</h2>
		<h3>7.3.1 使用Matrix控制变换(P292)</h3>
		<p class="point3">
			使用Matrix控制图形或组件变换的步骤:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. 获取Matrix对象, 该Matrix对象既可以创建, 也可以直接获取其他对象内封装的Matrix;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. 调用Matrix的方法进行平移、旋转、缩放、倾斜等;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;3. 将程序对Matrix所做的变换应用到指定图像或组件.
		</p>
		<p class="point3">
			Matrix控制平移、旋转和缩放的方法:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. setTranslate(float dx, float dy): 控制Matrix进行平移;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. setSkew(float kx, float ky, float px, float py): 控制Matrix以(px,py)为轴心进行倾斜, kx、ky为X、Y方向上的倾斜距离;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;3. setSkew(float kx, float ky): 控制Matrix进行倾斜, 
			kx、ky为X、Y方向上的倾斜距离;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;4. setRotate(float degress): 控制Matrix进行旋转, degress控制旋转的角度;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;5. setRotate(float degress, float px, float py): 设置以(px,py)为轴心进行旋转, degress控制旋转的角度;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;6. setScale(float sx, float sy): 控制Matrix进行缩放, sx、sy为X、Y方向上的缩放比例;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;7. setScale(float sx, float sy, float px, float py): 设置以(px,py)为轴心进行缩放, sx、sy为X、Y方向上的缩放比例.
		</p>
		<h3>7.3.2 使用drawBitmapMesh扭曲图像(P296)</h3>
		<p class="point3">
			drawBitmapMesh方法关键参数说明:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. bitmap: 需要扭曲的源位图;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. meshWidth: 该参数控制在横向上把该源位图划分成多少格;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;3. meshHeight: 该参数控制在纵向上把该源位图划分成多少格;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;4. verts: 该参数是一个长度为(meshWidth+1)*(meshHeight+1)*2的数组, 记录了扭曲后位图的各顶点位置;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;5. vertOffset: 控制verts数组中从第几个元素开始才对bitmap进行扭曲.
		</p>
		<h3>7.3.3 使用Shader填充图形(P299)</h3>
		<p class="point3">
			Android不仅可以使用颜色来填充图形, 也可以使用Shader对象指定的渲染效果来填充图形.
		</p>
		<p class="point3">
			抽象类Shader的实现类:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. BitmapShader: 使用位图填充的渲染效果;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. LinearGradient: 使用线性渐变来填充图形;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;3. RadialGradient: 使用圆形渐变来填充图形;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;4. SweepGradient: 使用角度渐变来填充图形;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;5. ComposeShader: 使用混合渲染效果来填充图形.
		</p>
		<h2>7.4 逐帧(Frame)动画(P302)</h2>
		<h3>7.4.1 AnimationDrawable与逐帧动画(P239)</h3>
		<p class="point3 code">
			逐帧动画的语法格式:<br>
			&lt;?xml version="1.0" encoding="utf-8"?><br>
			&lt;animation-list  xmlns:android="http://schemas.android.com/apk/res/android"<br>
			&nbsp;&nbsp;&nbsp;&nbsp;android:oneshot=["true" | "false"] >&lt;!--是否循环播放--><br>
			&nbsp;&nbsp;&nbsp;&nbsp;&lt;item android:drawable="@[package:]drawable/drawable_resource_name"<br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;android:duration="Integer" /><br>
			&lt;/animation-list>
		</p>
		<h2>7.5 补间(Tween)动画(P306)</h2>
		<p class="point3">
			补间动画就是指开发者只需指定动画开始、动画结束的关键帧, 而动画变化的中间帧由系统计算并补齐.
		</p>
		<h3>7.5.1 补间动画与Interpolator(P306)</h3>
		<p class="point3">
			Android使用Animation代表抽象的动画类, 其子类有:
			&nbsp;&nbsp;&nbsp;&nbsp;1. AlphaAnimation: 透明度改变的动画;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. ScaleAnimation: 大小改变的动画;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;3. TranslateAnimation: 位移变化的动画;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;4. RotateAnimation: 旋转动画;<br>
		</p>
		<p class="point3">
			Interpolator负责控制动画的变化速度, 使得基本的动画效果能以匀速、加速、减速抛物线速度等各种速度变化.
		</p>
		<h3>7.5.2 位置、大小、旋转度、透明度改变的补间动画(P307)</h3>
		<div class="exampleCode">
			<span class="example">示例代码<i></i></span>
			<pre class="code hidden">
&lt;?xml version="1.0" encoding="utf-8"?>
&lt;!-- 指定动画匀速变换 -->
&lt;set xmlns:android="http://schemas.android.com/apk/res/android"
    android:interpolator="@android:anim/linear_interpolator" >

    &lt;!-- 定义缩放变换 -->
    &lt;scale
        android:duration="3000"
        android:fillAfter="true"
        android:fromXScale="1.0"
        android:fromYScale="1.0"
        android:pivotX="50%"
        android:pivotY="50%"
        android:toXScale="0.01"
        android:toYScale="0.01" />
    
    &lt;!-- 定义透明度的变换 -->
    &lt;alpha
        android:duration="3000"
        android:fromAlpha="1"
        android:toAlpha="0.05" />

    &lt;!-- 定义旋转变换 -->
    &lt;rotate
        android:duration="3000"
        android:fromDegrees="0"
        android:pivotX="50%"
        android:pivotY="50%"
        android:toDegrees="1800" />

&lt;/set>
--------------------------------------
final ImageView flower = (ImageView) findViewById(R.id.p308_tween_animation_image);
final Animation shrink = AnimationUtils.loadAnimation(this,R.anim.p308_shrink_tween_animation);
// 设置动画结束后保留结束状态
shrink.setFillAfter(true);
flower.startAnimation(shrink);
			</pre>
		</div>
		<h3>7.5.3 自定义补间动画(P312)</h3>
		<p class="point3">
			自定义补间动画需要继承Animation类并重写applyTransformation(float interpolatedTime, Transformation t)方法, 参数说明: <br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. interpolatedTime: 代表动画的时间进行比. 不管动画实际的持续时间如何, 当动画播放时, 该参数总是自动从0变化到1的;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. Transformation: 该参数代表了补间动画在不同时刻对图形或组件的变形程度.
		</p>
		<p class="point3">
			Android需要借助Camera控制图片或视图进行三维空间的变换, 其常用方法如下:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. getMatrix(Matrix matrix): 将Camera所做的变换应用到指定的matrix上;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. rotateX(float deg): 将目标组件沿X轴旋转;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;3. rotateY(float deg): 将目标组件沿Y轴旋转;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;4. rotateZ(float deg): 将目标组件沿Z轴旋转;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;5. translate(float x, float y, float z): 把目标组件在三维空间里进行位移变换;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;6. applyToCanvas(Canvas canvas): 把Camera所做的变化应用到Canvas上.
		</p>
		<h2>7.6 使用SurfaceView实现动画(P315)</h2>
		<p class="point3">
			View的绘图机制存在的缺陷如下:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. Veiw缺乏双缓冲机制;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. 当程序需要更新View上的图像时, 程序必须重绘View上显示的整张图片.
		</p>
		<h3>7.6.1 SurfaceView的绘图机制(P315)</h3>
		<p class="point3">
			SurfaceView一般会与SurfaceHolder结合使用, SurfaceHolder用于向与之关联的SurfaceView上绘图, 调用SurfaceView的getHolder()方法即可获取SurfaceView关联的SurfaceHolder.
		</p>
		<p class="point3">
			SurfaceHolder获取Canvas对象的方法:<br>
			&nbsp;&nbsp;&nbsp;&nbsp;1. Canvas lockCanvas(): 锁定整个SurfaceView对象, 获取该Surface上的Canvas;<br>
			&nbsp;&nbsp;&nbsp;&nbsp;2. Canvas lockCanvas(Rect dirty): 锁定SurfaceView上Rect划分的区域, 获取该Surface上的Canvas.
		</p>
		<!-- InstanceEndEditable -->
	</div>
	<script type="text/javascript">
		window.onload = function() {
			var examples = document.getElementsByClassName("exampleCode"),
				len = examples.length;
			for(var i=0; i<len; i++) {
				examples[i].onclick = function() {
					showCode(this);
				}
			}
		};
		function showCode( element ) {
			console.log("click");
			var childNodes = element.childNodes,
				len = childNodes.length,
				codeNode, cls = "";
			for(var i=0; i<len; i++) {
				if(childNodes[i].getAttribute != undefined) {
					cls = childNodes[i].getAttribute("class");
				}
				if(cls != null && cls.length > 0 && cls.indexOf("hidden") > -1) {
					codeNode = childNodes[i];
					break;
				}
			}
			if( codeNode.style.display == "" || codeNode.style.display == "none") {
				codeNode.style.display = "block";
			} else {
				codeNode.style.display = "none";
			}
		}
	</script>
</body>
<!-- InstanceEnd -->
</html>